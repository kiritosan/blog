---
title: 寄生组合式继承
date: 2021-11-20 11:00:04
tags:
- js
- 前端
---
# 继承

## 原型式继承

```javascript
function object(o) {
    functjion F {}
    F.prototype = o;
    return new F();
}
```

Object.create()传入一个参数时和上面代码得到相同的效果

## 寄生式继承

在原型式继承基础上给克隆体原型增加方法

## 寄生组合式继承

寄生+原型链+借用构造函数

寄生是在原型式继承的基础上增加方法，把不增加方法当成寄生的一种特殊形式。即也可以把原型式继承当作寄生式继承的一种特殊形式。

寄生组合式继承可以解决组合继承子类原型有父类实例的实例属性的问题。组合继承同时还存在调用两次父类的问题。

解决方法是不直接将子类的原型指向父类的实例。而是通过克隆一个父类原型，然后将这个原型的constructor指向子类构造函数，将子类的原型指向这个克隆的父类原型，于是这个克隆的父类原型就成了子类的原型。
这个克隆的父类原型是通过寄生式继承取得的，所以这个克隆原型默认隐式指向父类原型。

## 与组合继承的不同点：

组成继承调用了父类构造函数，然后将生成的实例作为子类的原型，此方法使得子类原型拥有父类实例的实例属性。

寄生组合式继承采用了寄生的方式，没有调用父类构造函数，而是生成一个没有实例属性临时构造函数，这个临时构造函数根据父类的原型制造出一个没有实例属性的实例，然后将这个实例作为子类的原型，此方法由于在不会调用父类构造函数。

