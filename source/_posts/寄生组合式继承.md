---
title: 寄生组合式继承
date: 2021-11-20 11:00:04
tags:
- js
- 前端
---
# 继承

## 原型式继承

```javascript
function object(o) {
    functjion F {}
    F.prototype = o;
    return new F();
}
```

Object.create()传入一个参数时和上面代码得到相同的效果

## 寄生式继承

在原型式继承基础上给克隆体原型增加方法

## 寄生组合式继承

寄生+原型链+借用构造函数

寄生是指在使用原型式继承得到的无实例属性实例上增加方法，然后返回这个实例。可以将不增加方法的原型式继承看成寄生的一种特殊形式。

寄生组合式继承可以解决组合继承子类原型有父类实例的实例属性的问题。组合继承同时还存在调用两次父类的问题。

解决方法是不直接将子类的原型指向父类的实例。而是通过克隆一个父类原型，然后将这个原型的constructor指向子类构造函数，将子类的原型指向这个克隆的父类原型，于是这个克隆的父类原型就成了子类的原型。
这个克隆的父类原型是通过寄生式继承取得的，所以这个克隆原型默认隐式指向父类原型。

## 与组合继承的不同点：

组合继承调用了父类构造函数，然后将生成的实例作为子类的原型，此方法使得子类原型拥有父类实例的实例属性。

寄生组合式继承采用了寄生的方式，没有调用父类构造函数，而是生成一个没有实例属性临时构造函数，这个临时构造函数根据父类的原型制造出一个没有实例属性的实例，然后将这个实例作为子类的原型，此方法由于在给子类指定原型的时候不调用父类构造函数，所以子类的原型不会拥有父类实例的实例属性。而且在使用寄生组合式继承的时候，给子类原型指定了constructor为子类构造函数，而指定这个constructor的过程就是寄生的给实例增加方法的过程，在组合继承中子类原型不具有constructor属性。

