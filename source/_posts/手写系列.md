---
title: 手写系列
date: 2021-11-21 22:42:23
tags:
- js
---
# 手写系列

## 1. 数据类型判断

typeof()不能准确判断数据类型 比如Array、Date

思路：使用Object的原型的toString方法得到数据类型，然后通过slice和tolowercase去掉多余的部分整理成都是小写的形式。
subString也可以用，但是subString不能识别-1，所以只能通过求长度的方法得到右边的"]"索引，另外subStr即将被弃用。

```javascript
let typeOf = function(obj){Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()}
// 返回值都是undefined 为什么？因为没有返回值。

let typeOf = function(obj){
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()
}

function typeOf(obj) {
  // Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase() //需要reutrn
}

let typeOf = (obj) => (Object.prototype.toString.call(obj).slice(8, -1).toLowerCase())
```

```javascript
(function(){
  
})()
```

## 2. 继承

1. 原型链继承
（实现：实例属性定义在父类构造函数中，方法定义在父类原型中；子类原型指向父类的实例
缺点：原型中的引用类型实例属性会被所有子类实例共享，基本类型不会是因为复制的是值，而引用类型被复制的是地址。）
2. 借用构造函数继承
（实现：实例属性和方法都定义在父类构造函数中；子类原型指向父类实例
缺点：每次创建子类实例都会导致方法被创建一次。
但是解决了原型链继承的父类实例引用类型被子类实例共享的问题以及传参问题，传参问题？）
3. 组合继承
（以上两种方法的结合体，原型链继承是方法写在父类原型中，借用构造函数是借用父类的构造函数作为函数使用。原型链继承只用了原型链，借用构造函数只借用了构造函数。而在组合继承中将两种方法结合起来，给父类原型添加方法来继承方法，借用构造函数来继承实例属性。
那么给父类赋予属性是什么继承？？和原型链继承效果一样而且使得父类原型多了多余的属性。
所以原型链继承没有将实例属性也写到父类实例中，因为效果相同，反而改变父类实例更多。
原型链继承可以将属性和方法全都写入父类原型，但是发现属性写到构造函数效果相同，所以写到了构造函数，但是写到构造函数中还是不能使得每个子类实例获得独立的引用变量，于是子类构造函数需要借用父类构造函数声明和父类一样的子类实例属性；而借用构造函数继承会使得方法复制多份，所以将方法写到父类原型中。
缺点：调用两次父类构造函数）
4. 原型式继承
（无实例属性的临时构造函数根据父类原型创造一个无实例属性的实例作为子类原型）
5. 寄生
（原型式继承中得到的父类实例基础上给作为子类原型的无实例属性父类实例增加属性，然后将这个增强的父类实例作为子类原型）
6. 寄生组合继承
（为解决组合继承每次实例化子类时调用两次父类构造函数的问题，使用寄生组合继承。
寄生组合继承通过借用构造函数继承实例属性，通过原型链连接增强的父类原型继承方法）



```javascript
function SuperType(){
  this.type = 'typeA';
}

function SubType(){
}

SubType.prototype = new SuperType(); //实例化父类时已经继承了父类的属性，只是引用类型子类实例不能独立拥有 所以叫原型链继承

new SubType();
-----------------------------------------------------------------------------
function SuperType() {
  this.type = 'typeA';
}

function SubType(){
  SuperType(this);      //只是借用了构造函数而没有使用原型链改变父类构造函数 虽然子类使用原型链指向了父类实例
  this.func = function(){};
}

SubType.prototype = new SuperType();

new SubType();
-----------------------------------------------------------------------------






```


## ref

[36](https://juejin.cn/post/6946022649768181774#heading-0)

[传参问题](https://www.cnblogs.com/zhangguicheng/p/12768743.html)
意思是每个子类实例不能传参，而给作为子类原型的父类实例传参又不能保证每个子类实例有独立的实例属性（引用类型的情况）