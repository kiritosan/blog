---
title: 命名空间、词法环境、闭包
date: 2021-11-21 12:18:15
tags:
- js
---
# start

## 闭包

```javascript
(function() {
    // 函数创建一个命名空间

    window.foo = function() {
        // 对外公开的函数，创建了闭包
    };

})(); // 立即执行此匿名函数
```

闭包创建了命名空间（即词法环境），通过此方法可以避免在全局作用域（全局命名空间、全局词法环境）声明同一变量名引发的冲突。

例：

```javascript
(function() {
    // 函数创建一个命名空间
    a = 1;
    window.foo = function() {
        console.log(a)// 对外公开的函数，创建了闭包
    };

})(); // 立即执行此匿名函数

(function() {
    // 函数创建一个命名空间
    a = 2;
    window.foo2 = function() {
        console.log(a)// 对外公开的函数，创建了闭包
    };

})();

foo() //返回1
foo1() //返回2
```
通过两个即时执行函数创建了两个命名空间（词法环境），在这两个词法环境定义相同的变量名，不会引发变量名冲突。
同时，在执行```window.foo2 = function() {};```时，生成了一个闭包。
等号右边的函数一经定义，该匿名函数就会记录自己在哪里出生的，即拥有一个对创建它的词法环境的引用。而由于有这个引用，导致了即使即时执行函数执行完也不会使该词法环境被gc回收。

以上过程可以理解为：
1. 声明函数创建局部词法环境
2. 通过在函数中定义子函数从而使函数的词法环境保持被引用的状态，使得即使函数执行完毕其词法环境也不会被gc回收。（这个过程就是创建闭包的过程）

闭包：通过在一个函数内部定义子函数的方式使得这个函数的词法环境保持被引用的状态从而不会被gc回收。定义闭包不一定要return这个子函数或者给外部作用域赋值这个函数，即使只是声明子函数也会产生闭包，但是由于不能调用这个子函数所以不能访问到父函数词法环境。fun(1)(2)是先执行完fun(1)然后返回一个子函数，子函数由于引用父函数词法环境所以父函数词法环境不会消失，使得子函数可以访问到父函数的词法环境。

块级作用域和函数作用域的实现依托于执行上下文。let声明的变量不会提升，是因为在函数执行上下文中将所有用let变量声明的变量名记录到词法环境的环境记录ER中，值为uninitialized，所以在let声明前调用这个变量会报出没有初始化的错误，块级作用域得以实现。当在函数中用var声明变量时，函数执行上下文会将函数中的所有用var声明的变量名记录到变量环境中，并赋值为undefined，此时在var声明前访问这个变量会得到undefined值，这与var声明后不赋值然后访问的结果是相同的，于是就实现了hoisting，变量声明提升，而变量赋值不提升的效果。

执行上下文
- 词法环境
  - 环境记录RC 
  - 外层引用outer
  - this绑定
- 变量环境（只保存用var声明的变量，并赋值为undefined）


## ref

[命名空间](https://bonsaiden.github.io/JavaScript-Garden/zh/#function.scopes)

[词法环境](https://zh.javascript.info/closure)

[执行上下文、词法环境、变量环境](https://juejin.cn/post/6844904145372053511#heading-0)

[「变量提升」和「块级作用域」主要依托于执行上下文。 这句话正确且给予启发，然而链接的内容很大一部分是错误的](https://juejin.cn/post/6844904145372053511#heading-0)